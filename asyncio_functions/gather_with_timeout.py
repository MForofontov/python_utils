import asyncio
from collections.abc import Awaitable, Iterable
from typing import TypeVar

# Define a type variable for the items generated by the asynchronous generator
T = TypeVar("T")


async def gather_with_timeout(
    awaitables: Iterable[Awaitable[T]], timeout: float
) -> list[T]:
    """
    Gather asynchronous awaitables and enforce a timeout.

    Parameters
    ----------
    awaitables : Iterable[Awaitable[T]]
        Iterable of awaitable objects (e.g., coroutines) to execute. Each
        awaitable is wrapped in an ``asyncio.Task`` via ``asyncio.create_task``.
    timeout : float
        The maximum time in seconds to wait for the awaitables to complete.

    Returns
    -------
    list[T]
        The results of all awaitables that completed successfully.

    Raises
    ------
    asyncio.TimeoutError
        If the awaitables do not complete within the given timeout.

    Examples
    --------
    >>> async def long_task(i: int) -> int:
    >>>     await asyncio.sleep(i)
    >>>     return i
    >>> coros = [long_task(0.1), long_task(0.2)]
    >>> asyncio.run(gather_with_timeout(coros, timeout=1.0))
    [1, 2]
    """
    tasks = [asyncio.create_task(aw) for aw in awaitables]
    try:
        return await asyncio.wait_for(asyncio.gather(*tasks), timeout=timeout)
    except asyncio.TimeoutError:
        # Cancel all running tasks before re-raising
        for task in tasks:
            if not task.done():
                task.cancel()
        raise


__all__ = ["gather_with_timeout"]
